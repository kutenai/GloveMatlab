classdef eTransform < handle
    %eTransform Class for transforming images.
    %   This class contains all of my transforms. I have tried to make
    %   these as generic as practical, within time limitaions. The main
    %   idea is to share what I can, and at least contain the number
    %   crunching code here.
    
    properties
        tType   % The object is instantiated with a type.
        tMat    % Data for the transform.. most have some matrix
        tFunc   % Transform function.. just a concept right now
        tiFunc  % Inverse function
    end
    
    methods
        function obj = eTransform(tType,args)
            obj.tType = tType;
            if strcmp(tType,'perspective')
            elseif strcmp(tType,'nonlinear')
            end
        end
                
        function mat = PointsToMatrix(obj,pts)
            % Convert a column vector of x,y pairs to a column matrix where
            % each row is the 3rd order polynomial expansion (I think that
            % is the term to use).
            sz = size(pts,1);
            x = pts(:,1);
            y = pts(:,2);
            mat = [ones(sz,1) x y x.*y x.^2 y.^2 y.*(x.^2) x.*(y.^2) x.^3 y.^3];
        end
        
        function [acoffs, bcoffs] = warpCoefficients(obj,ptsA,ptsB)
            
            % Using this just for comparison.. note that my A and B
            % matrix values are identical, which makes me feel good
            %t_poly_ord3 = cp2tform(ptsB,ptsA,'polynomial', 3);
            
            % Convert the points to a matrix of [1 x y x*y ... etc.
            matA = obj.PointsToMatrix(ptsA);
            
            % Solve this as two seperate operations, first for the 
            % 'a' coefficients, then for the b coefficients.
            % Might be able to solve a single operation, but this is easier
            % and plenty fast.
            xout = ptsB(:,1);
            yout = ptsB(:,2);

            % Note: I can solve with either method, results are the same
            %acoffs = linsolve(matA,xout);
            %bcoffs = linsolve(matA,yout);
            acoffs = (matA'*matA)^-1 * matA' * xout;
            bcoffs = (matA'*matA)^-1 * matA' * yout;
        end
        
        function [ac, bc] = warpToSquare(obj,im,impts)
            % 
            [ac,bc] = obj.warpCoefficients(obj.images.square.pts,impts);

            rows = size(im,1);
            cols = size(im,2);
            
            [xI,yI] = obj.TranslateCoords(ac,bc,rows,cols);
            
            Ip = interp2(double(im),xI,yI,'*cubic');
            imshow(uint8(Ip),'Border','tight');
            
            % Uses Matlabs transform mechanism.
            % The coefficients that matlab generates are exactly the same a
            % s mine, so I have that going for me.. The imtranform does a
            % better job of the transform though.. I can't call it since it
            % uses some things generated by cp2tform that I do not have,
            % such as a forward function. I could not quite figure out how
            % they generated that.. so, I'll stick with  my simple but not
            % ideal solution for now.
            %t_poly_ord3 = cp2tform(impts,obj.images.square.pts,'polynomial', 3);
            %Ip2 = imtransform(im,t_poly_ord3,'bicubic');
            %figure;
            %imshow(uint8(Ip2),'Border','tight');
            
        end
        
        function [Xi,Yi] = TranslateCoords(obj,varargin)
            if strcmp(obj.tType,'nonlinear')
                [Xi,Yi] = obj.nlTranslateCoords(varargin{:});
                
            elseif strcmp(obj.tType,'perspective')
                [Xi,Yi] = obj.persTranslateCoords(varargin{:});
            end
        end
        
        function [xI, yI] = nlTranslateCoords(obj,varargin)
            % Given an image size, in rows and cols, generate a rows x cols
            % matrix of coordinates that have been translated by the ac and
            % bc coefficients.
            % returns two matrices, xI and yI, which are 2D matrics of x
            % and y coordinates.
            if size(varargin,2) < 4
                error('eTransform:TranslateCoords', ...
                    sprintf('Wrong number of input arguments for %s type.', ...
                    obj.tType));
            end
            ac = varargin{1};
            bc = varargin{2};
            rows = varargin{3};
            cols = varargin{4};

            rpts = 1:rows;
            cpts = 1:cols;
            
            xI = zeros(rows,cols);
            yI = zeros(rows,cols);
            for r = rpts
                for c = cpts
                    m  = [1 r c r*c r^2 c^2 c*r^2 r*c^2 r^3 c^3];
                    tx = m*ac;
                    ty = m*bc;
                    xI(r,c) = tx;
                    yI(r,c) = ty;
                end
            end
        end
        
        function Out = TranslateCoordinates(obj,H,In)
            In = [In ones(size(In,1),1)];
            Out = (H*In')';
            
            % After this.. we have 3 column vectors..
            % Column 1/column 3 is the X values.
            % Column 2/column 3 is the Y values.
            Out(:,1) = Out(:,1)./Out(:,3);
            Out(:,2) = Out(:,2)./Out(:,3);
            Out = Out(:,1:2); % lop off last column
        end
        
        function [a,b] = xlcoord(obj,H,x,y)
            % Translate a single coordinate.
            t = (H*[x y 1]')';
            a = t(1)/t(3);
            b = t(2)/t(3);
        end
        
        function [x1,y1,x2,y2] = determineExtents(obj,H,rows,cols)
            % when we perspective transform, we will translate the 1:rows
            % and 1:cols coordinates into a new space. The new space may
            % not (almost certainly will not) transform the entire input
            % image into the output..
            % After some serious futzing... I finally figured out that I
            % could inverse transform the input image coordinates (the 4
            % corners) and this will give me the 4 corners of the source
            % transform I should use for interp2 to insure that the output
            % image contains the entire image..
            
            [x1,y1] = obj.xlcoord(H^-1,1,1);
            extents = [x1 y1];
            [x1,y1] = obj.xlcoord(H^-1,1,rows);
            extents = [extents;x1 y1];
            [x1,y1] = obj.xlcoord(H^-1,cols,rows);
            extents = [extents;x1 y1];
            [x1,y1] = obj.xlcoord(H^-1,cols,1);
            extents = [extents;x1 y1];
            
            x1 = min(extents(:,1));
            x2 = max(extents(:,1));
            y1 = min(extents(:,2));
            y2 = max(extents(:,2));
           
        end
        
        function [Xi, Yi] = persTranslateCoords(obj,varargin)
            % Given an image size, in rows and cols, generate a rows x cols
            % matrix of coordinates that have been translated by the ac and
            % bc coefficients.
            % returns two matrices, xI and yI, which are 2D matrics of x
            % and y coordinates.
            
            % This function also supports the capability of extending the
            % matrix to the left, right, top and bottom (need better
            % control of this). The extended matrix will then force interp2
            % to generate a larger output image. Depending on the
            % perspective translation, the large image is needed in order
            % to capture all points.
            
            % Use varargin to allow the excess factors to be passed in.
            if size(varargin,2) < 3
                error('eTransform:TranslateCoords',sprintf('Wrong number of input arguments for %s type.',obj.tType));
            end
            H = varargin{1};
            rows = varargin{2};
            cols = varargin{3};
            
            autoScale = 0;

            if size(varargin,2) > 3
                autoScale = varargin{4};
            end
            
            [x1,y1,x2,y2] = obj.determineExtents(H,rows,cols);
            
            % Okay, X is across the columns,
            % Y is across the rows. Upper left is 0,0 or 1,1
            % Note: 
                % ROWS of X are copies of 1:cols
                % COLS of Y are copies of 1:rows
            % 
            %[X,Y] = meshgrid(-1*lfactor*cols:rfactor*cols,-1*lfactor*rows:rfactor*rows);
            %[X,Y] = meshgrid(1:1.5*cols,-1.5*rows:1.5*rows);
            %[X,Y] = meshgrid(1:cols,1:rows);
            if autoScale
                YMax = autoScale;
                XMax = ceil(YMax*((x2-x1)/(y2-y1)));
                Xincr = max(floor(x2-x1)/XMax,1);
                Yincr = max(floor(y2-y1)/YMax,1);
            else
                Xincr = 1;
                Yincr = 1;
            end
            [X,Y] = meshgrid(x1:Xincr:x2,y1:Yincr:y2);
            
            nPoints = length(X(:));
            % Reshape these to be 3 column vectors of X,Y,1 values.
            % I put them this way becuase Matlab will view a long column
            % vector, but hates wide row vectors..
            In = [reshape(X,nPoints,1) reshape(Y,nPoints,1) ones(nPoints,1)];
            
            % Transpose In, multiply by H to apply the transform, then,
            % transpose the results. This will result in another long
            % column vector of [X Y 1];
            Out = (H*In')';
            
            % After this.. we have 3 column vectors..
            % Column 1/column 3 is the X values.
            % Column 2/column 3 is the Y values.
            Xi = Out(:,1)./Out(:,3);
            Yi = Out(:,2)./Out(:,3);
            
            xmin = min(Xi);
            xmax = max(Xi);
            ymin = min(Yi);
            ymax = max(Yi);
            
            % Now, take the X column and reshape into a matrix.
            % Do the same with the Y column.
            % This should return the value to their modified versions.
            Xi = reshape(Xi,size(X,1),size(X,2));
            Yi = reshape(Yi,size(X,1),size(X,2));
        end
        
        function H = calcPerspectiveMatrix(obj,ptsA,ptsB)
            % Perform the Point translation as described in class.

            % Assert that the arguments are reasonable.
            assert(all(size(ptsA) == size(ptsB)));
            assert(size(ptsA,2) >= 2);
            
            x = ptsA(:,1);
            y = ptsA(:,2);
            u = ptsB(:,1);
            v = ptsB(:,2);
            
            N = length(ptsA);
            
            % Form an N by 3 vector of the x,y input coordinates.
            Xi  = [x y ones(N,1)];
            
            % Convenience.. 3 zeros
            mZero = [0 0 0];

            A = zeros(2*N,9); % Preallocate the output array

            % Build the A matrix
            % This matrix will have an extra column, which I'll
            % lop off later.
            for x = 1:N
                xi = Xi(x,:);
                A(2*x-1,:) = [xi    mZero -u(x)*xi];
                A(2*x,:)   = [mZero xi    -v(x)*xi];
            end
            
            % Lop off the last column
            A = A(:,1:8);
            
            % This is the u and v values intersperesed, as needed
            uv = reshape([u v]',N*2,1);
            if N == 4
                h1 = A^-1*uv; % Calculate the actual coefficients
                h = (A'*A)^-1 * A' * uv;
            else
                h = (A'*A)^-1 * A' * uv;
            end
            
            h = [h' 1]; % Add one more item to round out to 3x3
            H = reshape(h,3,3)'; % And put it into our required format.
        end
        
        function img = interp2(obj,img,Xi,Yi)
            % My version of interp2...
            img = interp2(double(img),Xi,Yi,'*bilinear',0);
            return;
            
            % If I get time, I will build this, but I'm using the matlab
            % version for now.
            assert(all(size(Xi) == size(Yi)));
            rows = size(img,1);
            cols = size(img,2);
            
            r2 = size(Xi,1);
            c2 = size(Xi,2);
            
            [X,Y] = meshgrid(1:cols,1:rows);
            
            minXi = min(Xi(:));
            maxXi = max(Xi(:));
            minYi = min(Yi(:));
            maxYi = max(Yi(:));
            
            newRows = ceil(maxYi)-floor(minYi);
            newCols = ceil(maxXi)-floor(minXi);
            
            newImg = zeros(newRows,newCols);
            
            scaleX = newCols/cols;
            scaleY = newRows/rows;
            
            for r = 1:newrows
                for c = 1:newcols
                end
            end
        end
        
        function img = ImgTransform(obj,H,img)
            % This one uses Perspective transform
            rows = size(img,1);
            cols = size(img,2);
            [Xi,Yi] = obj.TranslateCoords(H,rows,cols);
            
            [X,Y] = meshgrid(1:cols,1:rows);
            %imgray = rgb2gray(img);
            imgray = img;
            im2 = interp2(double(imgray),Yi,Xi,'*bilinear',0);
            img = uint8(im2);
        end
        
    end
    
end

